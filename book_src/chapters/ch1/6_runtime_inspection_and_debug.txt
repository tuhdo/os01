Runtime inspection and debug

A [margin:
debugger
]debuggerdebugger is a program that allows inspection of a
running program. A debugger can start and run a program then stop
at a specific line for examining the state of the program at that
point. The point where the debugger stop (but not halt) is called
a breakpoint.

We will be using the GDB - GNU Debugger for debugging our kernel.
gdb is the program name. gdb can do four main kinds of things:

• Start your program, specifying anything that might affect its
  behavior.

• Make your program stop on specified conditions.

• Examine what has happened, when your program has stopped

• Change things in your program, so you can experiment with
  correcting the effects of one bug and go on to learn about
  another

  A sample program

There must be an existing program for debugging. The good old “
Hello World” program suffices for the educational purpose in this
chapter:

#include <stdio.h>



int main(int argc, char *argv[])

{

    printf("Hello World!\n");

    return 0;

}

We compile it with debugging information with the option -g:



$ gcc -m32 -g hello.c -o hello



Finally, we start gdb with the program as argument:



$ gdb hello



  Static inspection of a program

Before inspecting a program at runtime, gdb loads it first. Upon
loading into memory (but without running), a lot of useful
information can be retrieve for inspection. The commands in this
section can be used before the program runs. However, they are
also usable when the program runs and can display even more
information.

  Command: info target/info file/info files

This command prints the information of the target being debugged.
A target is the debugging program.

The output of the command from hello program, a local target in
detail:



  (gdb) info target





  Symbols from "/tmp/hello".

  Local exec file:

  	`/tmp/hello', file type elf32-i386.

  	Entry point: 0x8048310

  	0x08048154 - 0x08048167 is .interp

  	0x08048168 - 0x08048188 is .note.ABI-tag

  	0x08048188 - 0x080481ac is .note.gnu.build-id

  	0x080481ac - 0x080481cc is .gnu.hash

  	0x080481cc - 0x0804821c is .dynsym

  	0x0804821c - 0x08048266 is .dynstr

  	0x08048266 - 0x08048270 is .gnu.version

  	0x08048270 - 0x08048290 is .gnu.version_r

  	0x08048290 - 0x08048298 is .rel.dyn

  	0x08048298 - 0x080482a8 is .rel.plt

  	0x080482a8 - 0x080482cb is .init

  	0x080482d0 - 0x08048300 is .plt

  	0x08048300 - 0x08048308 is .plt.got

  	0x08048310 - 0x080484a2 is .text

  	0x080484a4 - 0x080484b8 is .fini

  	0x080484b8 - 0x080484cd is .rodata

  	0x080484d0 - 0x080484fc is .eh_frame_hdr

  	0x080484fc - 0x080485c8 is .eh_frame

  	0x08049f08 - 0x08049f0c is .init_array

  	0x08049f0c - 0x08049f10 is .fini_array

  	0x08049f10 - 0x08049f14 is .jcr

  	0x08049f14 - 0x08049ffc is .dynamic

  	0x08049ffc - 0x0804a000 is .got

  	0x0804a000 - 0x0804a014 is .got.plt

  	0x0804a014 - 0x0804a01c is .data

  	0x0804a01c - 0x0804a020 is .bss



  The output displayed reports:

  • Path of a symbol file. A symbol file is the file that
    contains the debugging information. Usually, this is the same
    file as the binary, but it is common to separate between an
    executable binary and its debugging information into 2 files,
    especially for remote debugging. In the example, it is this
    line:

    Symbols from "/tmp/hello".

  • The path of the debugging program and its file type. In the
    example, it is this line:

    Local exec file:

    	`/tmp/hello', file type elf32-i386.

  • The entry point to the debugging program. That is, the very
    first code the program runs. In the example, it is this line:

    Entry point: 0x8048310

  • A list of sections with its starting and ending addresses. In
    the example, it is the remaining output.



If the debugging program runs in a different machine, it is a
remote target and gdb only prints a brief information:



  (gdb) info target





  Remote serial target in gdb-specific protocol:

  Debugging a target over a serial line.





  Command: maint info sections

This command is similar to info target but give extra information
about program sections, specifically the file offset and the
flags of each section.

Here is the output when running against hello program:



  (gdb) maint info sections





  Exec file:

      `/tmp/hello', file type elf64-x86-64.

   [0]     0x00400238->0x00400254 at 0x00000238: .interp ALLOC
  LOAD READONLY DATA HAS_CONTENTS

   [1]     0x00400254->0x00400274 at 0x00000254: .note.ABI-tag
  ALLOC LOAD READONLY DATA HAS_CONTENTS

   [2]     0x00400274->0x00400298 at 0x00000274:
  .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS

   [3]     0x00400298->0x004002b4 at 0x00000298: .gnu.hash ALLOC
  LOAD READONLY DATA HAS_CONTENTS

   [4]     0x004002b8->0x00400318 at 0x000002b8: .dynsym ALLOC
  LOAD READONLY DATA HAS_CONTENTS

   [5]     0x00400318->0x00400355 at 0x00000318: .dynstr ALLOC
  LOAD READONLY DATA HAS_CONTENTS

   [6]     0x00400356->0x0040035e at 0x00000356: .gnu.version
  ALLOC LOAD READONLY DATA HAS_CONTENTS

   [7]     0x00400360->0x00400380 at 0x00000360: .gnu.version_r
  ALLOC LOAD READONLY DATA HAS_CONTENTS

  ....remaining output omitted....



The output is similar to info target, but with more details. Next
to the section names are the section flags, which are attributes
of a section. Here, we can see that the sections with LOAD flag
are from LOAD segment. The command can be combined with the
section flags for filtered outputs:

  ALLOBJ displays sections for all loaded object files, including
  shared libraries. Shared libraries are only displayed when the
  program is already running.

  section names displays only named sections.

  The command:



    (gdb) maint info sections .text .data .bss



    only displays .text, .data and .bss sections:



    Exec file:

        `/tmp/hello', file type elf64-x86-64.

     [13]     0x00400430->0x004005c2 at 0x00000430: .text ALLOC
    LOAD READONLY CODE HAS_CONTENTS

     [24]     0x00601028->0x00601038 at 0x00001028: .data ALLOC
    LOAD DATA HAS_CONTENTS

     [25]     0x00601038->0x00601040 at 0x00001038: .bss ALLOC



  section-flags displays only sections with specified section
  flags. Note that these section flags are specific to gdb,
  though it is based on the section attributes defined
  previously. Currently, gdb understands the following flags:

  ALLOC Section will have space allocated in the process when
    loaded. Set for all sections except those containing debug
    information.

  LOAD Section will be loaded from the file into the child
    process memory. Set for pre-initialized code and data, clear
    for .bss sections.

  RELOC Section needs to be relocated before loading.

  READONLY Section cannot be modified by the child process.

  CODE Section contains executable code only.

  DATA Section contains data only (no executable code).

  ROM Section will reside in ROM.

  CONSTRUCTOR Section contains data for constructor/destructor
    lists.

  HAS_CONTENTS Section is not empty.

  NEVER_LOAD An instruction to the linker to not output the
    section.

  COFF_SHARED_LIBRARY A notification to the linker that the
    section contains COFF shared library information. COFF is an
    object file format, similar to ELF. While ELF is the file
    format for an executable binary, COFF is the file format for
    an object file.

  IS_COMMON Section contains common symbols.

  We can restrict the output to only display sections that
  contain code with the command:



    (gdb) maint info sections CODE



    The output:



    Exec file:

        `/tmp/hello', file type elf64-x86-64.

     [10]     0x004003c8->0x004003e2 at 0x000003c8: .init ALLOC
    LOAD READONLY CODE HAS_CONTENTS

     [11]     0x004003f0->0x00400420 at 0x000003f0: .plt ALLOC
    LOAD READONLY CODE HAS_CONTENTS

     [12]     0x00400420->0x00400428 at 0x00000420: .plt.got
    ALLOC LOAD READONLY CODE HAS_CONTENTS

     [13]     0x00400430->0x004005c2 at 0x00000430: .text ALLOC
    LOAD READONLY CODE HAS_CONTENTS

     [14]     0x004005c4->0x004005cd at 0x000005c4: .fini ALLOC
    LOAD READONLY CODE HAS_CONTENTS



  Command: info functions

This commands list all function names and their loaded addresses.
The names can be filtered with a regular expression.

Run the command, we get the following output:



  (gdb) info functions





  All defined functions:

  File hello.c:

  int main(int, char **);

  Non-debugging symbols:

  0x00000000004003c8  _init

  0x0000000000400400  puts@plt

  0x0000000000400410  __libc_start_main@plt

  0x0000000000400430  _start

  0x0000000000400460  deregister_tm_clones

  0x00000000004004a0  register_tm_clones

  0x00000000004004e0  __do_global_dtors_aux

  0x0000000000400500  frame_dummy

  0x0000000000400550  __libc_csu_init

  0x00000000004005c0  __libc_csu_fini

  0x00000000004005c4  _fini



  Command: info variables

This command lists all global and static variable names, or
filtered with a regular expression.

If we add a global variable int i into the sample source program
and recompile then run the command, we get the following output:



  (gdb) info variables





  All defined variables:



  File hello.c:

  int i;



  Non-debugging symbols:

  0x00000000004005d0  _IO_stdin_used

  0x00000000004005e4  __GNU_EH_FRAME_HDR

  0x0000000000400708  __FRAME_END__

  0x0000000000600e10  __frame_dummy_init_array_entry

  0x0000000000600e10  __init_array_start

  0x0000000000600e18  __do_global_dtors_aux_fini_array_entry

  0x0000000000600e18  __init_array_end

  0x0000000000600e20  __JCR_END__

  0x0000000000600e20  __JCR_LIST__

  0x0000000000600e28  _DYNAMIC

  0x0000000000601000  _GLOBAL_OFFSET_TABLE_

  0x0000000000601028  __data_start

  0x0000000000601028  data_start

  0x0000000000601030  __dso_handle

  0x000000000060103c  __bss_start

  0x000000000060103c  _edata

  0x000000000060103c  completed

  0x0000000000601040  __TMC_END__

  0x0000000000601040  _end



  Command: disassemble/disas

This command displays the assembly code of the executable file.

gdb can display the assembly code of a function:



  (gdb) disassemble main





  Dump of assembler code for function main:

     0x0804840b <+0>: 	lea    ecx,[esp+0x4]

     0x0804840f <+4>: 	and    esp,0xfffffff0

     0x08048412 <+7>: 	push   DWORD PTR [ecx-0x4]

     0x08048415 <+10>:	push   ebp

     0x08048416 <+11>:	mov    ebp,esp

     0x08048418 <+13>:	push   ecx

     0x08048419 <+14>:	sub    esp,0x4

     0x0804841c <+17>:	sub    esp,0xc

     0x0804841f <+20>:	push   0x80484c0

     0x08048424 <+25>:	call   0x80482e0 <puts@plt>

     0x08048429 <+30>:	add    esp,0x10

     0x0804842c <+33>:	mov    eax,0x0

     0x08048431 <+38>:	mov    ecx,DWORD PTR [ebp-0x4]

     0x08048434 <+41>:	leave

     0x08048435 <+42>:	lea    esp,[ecx-0x4]

     0x08048438 <+45>:	ret

  End of assembler dump.



  It would be more useful if source is included:



  (gdb) disassemble /s main





  Dump of assembler code for function main:

  hello.c:

  4	{

     0x0804840b <+0>:	lea     ecx,[esp+0x4]

     0x0804840f <+4>:	and     esp,0xfffffff0

     0x08048412 <+7>:	push    DWORD PTR [ecx-0x4]

     0x08048415 <+10>:	push   ebp

     0x08048416 <+11>:	mov    ebp,esp

     0x08048418 <+13>:	push   ecx

     0x08048419 <+14>:	sub    esp,0x4

  5	    printf("Hello World!\n");

     0x0804841c <+17>:	sub    esp,0xc

     0x0804841f <+20>:	push   0x80484c0

     0x08048424 <+25>:	call   0x80482e0 <puts@plt>

     0x08048429 <+30>:	add    esp,0x10

  6	    return 0;

     0x0804842c <+33>:	mov    eax,0x0

  7	}

     0x08048431 <+38>:	mov    ecx,DWORD PTR [ebp-0x4]

     0x08048434 <+41>:	leave

     0x08048435 <+42>:	lea    esp,[ecx-0x4]

     0x08048438 <+45>:	ret

  End of assembler dump.



  Now the high level source (in green text) is included as part
  of the assembly dump. Each line is backed by the corresponding
  assembly code below it.



If the option /r is added, raw instructions in hex are included,
just like how objdump displays assembly code by default:



  (gdb) disassemble /rs main





  Dump of assembler code for function main:

  hello.c:

  4	{

     0x0804840b <+0>:	 8d 4c 24 04	   lea    ecx,[esp+0x4]

     0x0804840f <+4>:	 83 e4 f0	      and    esp,0xfffffff0

     0x08048412 <+7>:	 ff 71 fc	      push   DWORD PTR [ecx-0x4]

     0x08048415 <+10>:	55	  push   ebp

     0x08048416 <+11>:	89 e5   mov    ebp,esp

     0x08048418 <+13>:	51	  push   ecx

     0x08048419 <+14>:	83 ec 04	      sub    esp,0x4

  5	    printf("Hello World!\n");

     0x0804841c <+17>:	83 ec 0c	      sub    esp,0xc

     0x0804841f <+20>:	68 c0 84 04 08	push   0x80484c0

     0x08048424 <+25>:	e8 b7 fe ff ff	call   0x80482e0 <puts@plt>

     0x08048429 <+30>:	83 c4 10	      add    esp,0x10

  6	    return 0;

     0x0804842c <+33>:	b8 00 00 00 00	mov    eax,0x0

  7	}

     0x08048431 <+38>:	8b 4d fc	      mov    ecx,DWORD PTR
  [ebp-0x4]

     0x08048434 <+41>:	c9	leave

     0x08048435 <+42>:	8d 61 fc	      lea    esp,[ecx-0x4]

     0x08048438 <+45>:	c3	ret

  End of assembler dump.



  A function in a specific file can also be specified:



  (gdb) disassemble /sr 'hello.c'::main





  Dump of assembler code for function main:

  hello.c:

  4	{

     0x0804840b <+0>:	 8d 4c 24 04	  lea    ecx,[esp+0x4]

     0x0804840f <+4>:	 83 e4 f0	     and    esp,0xfffffff0

     0x08048412 <+7>:	 ff 71 fc	     push   DWORD PTR [ecx-0x4]

     0x08048415 <+10>:	55	   push   ebp

     0x08048416 <+11>:	89 e5	mov    ebp,esp

     0x08048418 <+13>:	51	   push   ecx

     0x08048419 <+14>:	83 ec 04	      sub    esp,0x4

  5	    printf("Hello World!\n");

     0x0804841c <+17>:	83 ec 0c	      sub    esp,0xc

     0x0804841f <+20>:	68 c0 84 04 08	push   0x80484c0

     0x08048424 <+25>:	e8 b7 fe ff ff	call   0x80482e0 <puts@plt>

     0x08048429 <+30>:	83 c4 10	      add    esp,0x10

  6	    return 0;

     0x0804842c <+33>:	b8 00 00 00 00	mov    eax,0x0

  7	}

     0x08048431 <+38>:	8b 4d fc	      mov    ecx,DWORD PTR
  [ebp-0x4]

     0x08048434 <+41>:	c9	leave

     0x08048435 <+42>:	8d 61 fc	      lea    esp,[ecx-0x4]

     0x08048438 <+45>:	c3	ret

  End of assembler dump.



  The filename must be included in a single quote, and the
  function must be prefixed by double colons e.g. 'hello.c'::main
  to specify disassembling of the function main in the file
  hello.c.

  Command: x

This command examines the content of a given memory range.

We can examine the raw content of main:



  (gdb) x main





  0x804840b <main>:	0x04244c8d



  By default, without any argument, the command only prints the
  content of a single memory address. In this case, that is the
  starting memory address of main.



With format arguments, the command can print a range of memory in
a specific format.



  (gdb) x/20b main





  0x804840b <main>:	   0x8d	0x4c	0x24	0x04	0x83	0xe40xf0	0xff

  0x8048413 <main+8>:	 0x71	0xfc	0x55	0x89	0xe5	0x510x83	0xec

  0x804841b <main+16>:	0x04	0x83	0xec	0x0c



  /20b main argument means that the command prints 20 bytes,
  where main starts in memory.

The general form for format argument is: /<repeated count><format
letter>

If the repeated count is not supplied, by default gdb supplies
the count as 1. The format letter is one the following value:


+---------+-------------------------------------------------------------------------------------------------+
| Letter  | Description                                                                                     |
+---------+-------------------------------------------------------------------------------------------------+
+---------+-------------------------------------------------------------------------------------------------+
| o       | Print the memory content in octal format.                                                       |
+---------+-------------------------------------------------------------------------------------------------+
| x       | Print the memory content in hex format.                                                         |
+---------+-------------------------------------------------------------------------------------------------+
| d       | Print the memory content in decimal format.                                                     |
+---------+-------------------------------------------------------------------------------------------------+
| u       | Print the memory content in unsigned decimal format.                                            |
+---------+-------------------------------------------------------------------------------------------------+
| t       | Print the memory content in binary format.                                                      |
+---------+-------------------------------------------------------------------------------------------------+
| f       | Print the memory content in float format.                                                       |
+---------+-------------------------------------------------------------------------------------------------+
| a       | Print the memory content as memory addresses.                                                   |
+---------+-------------------------------------------------------------------------------------------------+
| i       | Print the memory content as a series of assembly instructions,
similar to disassemble command. |
+---------+-------------------------------------------------------------------------------------------------+
| c       | Print the memory content as an array of ASCII characters.                                       |
+---------+-------------------------------------------------------------------------------------------------+
| s       | Print the memory content as a string                                                            |
+---------+-------------------------------------------------------------------------------------------------+


Depends on the circumstance, certain format is advantageous than
the others. For example, if a memory region contains
floating-point numbers, then it is better to use the format f
than viewing the number as separated 1-byte hex numbers.

  Command: print/p

Examining raw memory is useful but usually it is better to have a
more human-readable output. This command does precisely the task:
it pretty-prints an expression. An expression can be a global
variable, a local variable in current stack frame, a function, a
register, a number...

  Runtime inspection of a program

The main use of a debugger is to examine the state of a program,
when it is running. gdb provides a set of useful commands for
retrieving useful runtime information.

  Command: run

This command starts running the program.

Run the hello program:



  (gdb) r





  Starting program: /tmp/hello

  Hello World!

  [Inferior 1 (process 1002) exited normally]



  The program runs successfully and printed the message “Hello
  World”. However, it would not be useful if all gdb can do is
  run a program.

  Command: break/b

This command sets a breakpoint at a location in the high-level
source code. When gdb runs to a specific location marked by a
breakpoint, it stops executing for a programmer to inspect the
current state of a program.

A breakpoint can be set on a line as displayed by an editor.
Suppose we want to set a breakpoint at line 3 of the program,
which is the start of main function:

  #include <stdio.h>



@|\color{red}\bfseries int main(int argc, char *argv[])|@

{

    printf("Hello World!\n");

    return 0;

}

  When running a program, instead of running from start to
  finish, gdb stopped at line 3:



  (gdb) b 3





  Breakpoint 1 at 0x400535: file hello.c, line 3.





  (gdb) r





  Starting program: /tmp/hello

  Breakpoint 1, main (argc=1, argv=0x7fffffffdfb8) at hello.c:5

  5	    printf("Hello World!\n");



  The breakpoint is at line 3, but gdb stopped line 5. The reason
  is that line 3 does not contain code, but a function signature;
  gdb only stops where it can execute code. The code in the
  function starts at line 5, the call to printf, so gdb stops
  there.



Line of code is not always the reliable way to specify a
breakpoint, as the source code can be changed. What if gdb should
always stop at main function? In this case, a better method is to
use the function name directly:



  b main



  Then, regardless of how the source code changes, gdb always
  stops at the main function.



Sometimes, the debugging program does not contain debug info, or
gdb is debugging assembly code. In that case, a memory address
can be specified as a stop point. To get the function address,
print command can be used:



  (gdb) print main





  $3 = {int (int, char **)} 0x400526 <main>



  Knowing the address of main, we can easily set a breakpoint
  with a memory address:



  b *0x400526





gdb can also set breakpoint in any source file. Suppose that
hello program is composed not just one file but many files e.g.
hello1.c, hello2.c, hello3.c... In that case, simply add the
filename before either a line number:



  b hello.c:3





A function name in a specific file can also be set:



  b hello.c:main



  Command: next/n

This command executes the current line and stops at the next
line. When the current line is a function call, steps over it.

After setting a breakpoint at main, run a program and stop at the
first printf:



  (gdb) r





  Starting program: /tmp/hello

  Breakpoint 1, main (argc=1, argv=0x7fffffffdfb8) at hello.c:5

  5	    printf("Hello World!\n");



  Then, to proceed to the next statement, we use the next
  command:



  (gdb) n





  Hello World!

  6	    return 0;



  In the output, the first line shows the output produced after
  executing line 5; then, the next line shows where gdb stops
  currently, which is line 6.

  Command: step/s

This command executes the current line and stops at the next
line. When the current line is a function call, steps into it to
the first next line in the called function.

Suppose we have a new function add[footnote:
Why should we add a new function and function call instead of
using the existing printf call? Stepping into shared library
functions is tricky because to make debugging works, the debug
info must be installed and loaded. It is not worth the trouble
for demonstrating this simple command.
]:

  #include <stdio.h>



int add(int a, int b) {

	return a + b;

}



int main(int argc, char *argv[])

{

	add(1, 2);

    printf("Hello World!\n");

    return 0;

}

  If step command is used instead of next on the function call
  printf, gdb steps inside the function:



  (gdb) r





  Starting program: /tmp/hello

  Breakpoint 1, main (argc=1, argv=0xffffd154) at hello.c:11

  11	    add(1, 2);





  (gdb) s





  add (a=1, b=2) at hello.c:6

  6	    return a + b;



  After executing the command s, gdb stepped into the add
  function where the first statement is a return.

  Command: ni

At the core, gdb operates on assembly instruction. Source line by
line debugging is simply an enhancement to make it friendlier for
programmers. Each statement in C translates to one or more
assembly instruction, as shown with objdump and disassemble
command. With the debug info available, gdb knows how many
instructions belong to one line of high-level code; line by line
debugging is just a execution of assembly instructions of a line
when moving from the current line to the next.

This command executes the one assembly instruction belongs to the
current line. Until all assembly instructions of the current line
are executed, gdb will not move to the next line. If the current
instruction is a call, step over it to the next instruction.

When breakpoint is on the printf call and ni is used, it steps
through each assembly instruction:



  (gdb) disassemble /s main





  Dump of assembler code for function main:

  hello.c:

  4	{

     0x0804840b <+0>:	 lea    ecx,[esp+0x4]

     0x0804840f <+4>:	 and    esp,0xfffffff0

     0x08048412 <+7>:	 push   DWORD PTR [ecx-0x4]

     0x08048415 <+10>:	push   ebp

     0x08048416 <+11>:	mov    ebp,esp

     0x08048418 <+13>:	push   ecx

     0x08048419 <+14>:	sub    esp,0x4

  5	    printf("Hello World!\n");

     0x0804841c <+17>:	sub    esp,0xc

     0x0804841f <+20>:	push   0x80484c0

     0x08048424 <+25>:	call   0x80482e0 <puts@plt>

     0x08048429 <+30>:	add    esp,0x10

  6	    return 0;

  => 0x0804842c <+33>:	mov    eax,0x0

  7	}

     0x08048431 <+38>:	mov    ecx,DWORD PTR [ebp-0x4]

     0x08048434 <+41>:	leave

     0x08048435 <+42>:	lea    esp,[ecx-0x4]

     0x08048438 <+45>:	ret

  End of assembler dump.





  (gdb) r





  Starting program: /tmp/hello

  Breakpoint 1, main (argc=1, argv=0xffffd154) at hello.c:5

  5	    printf("Hello World!\n");





  (gdb) ni





  0x0804841f	5	    printf("Hello World!\n");





  (gdb) ni





  0x08048424	5	    printf("Hello World!\n");





  (gdb) ni





  Hello World!

  0x08048429	5	    printf("Hello World!\n");





  (gdb)





  6	    return 0;



  Upon entering ni, gdb executes current instruction and display
  the next instruction. That's why from the output, gdb only
  displays 3 addresses: 0x0804841f, 0x08048424 and 0x08048429.
  The instruction at 0x0804841c, which is the first instruction
  of printf, is not displayed because it is the first instruction
  that gdb stopped at. Assume that gdb stopped at the first
  instruction of printf at 0x0804841c, the current instruction
  can be displayed using x command:



  (gdb) x/i $eip





  => 0x804841c <main+17>: sub    esp,0xc



  Command: si

Similar to ni, this command executes the current assembly
instruction belongs to the current line. But if the current
instruction is a call, step into it to the first next instruction
in the called function.

Recall that the assembly code generated from printf contains a
call instruction:



  (gdb) disassemble /s main





  Dump of assembler code for function main:

  hello.c:

  4	{

     0x0804840b <+0>:	lea    ecx,[esp+0x4]

     0x0804840f <+4>:	and    esp,0xfffffff0

     0x08048412 <+7>:	push   DWORD PTR [ecx-0x4]

     0x08048415 <+10>:	push   ebp

     0x08048416 <+11>:	mov    ebp,esp

     0x08048418 <+13>:	push   ecx

     0x08048419 <+14>:	sub    esp,0x4

  5	    printf("Hello World!\n");

     0x0804841c <+17>:	sub    esp,0xc

     0x0804841f <+20>:	push   0x80484c0

     0x08048424 <+25>:	call   0x80482e0 <puts@plt>

     0x08048429 <+30>:	add    esp,0x10

  6	    return 0;

  => 0x0804842c <+33>:	mov    eax,0x0

  7	}

     0x08048431 <+38>:	mov    ecx,DWORD PTR [ebp-0x4]

     0x08048434 <+41>:	leave

     0x08048435 <+42>:	lea    esp,[ecx-0x4]

     0x08048438 <+45>:	ret

  End of assembler dump.



  We try instruction by instruction stepping again, but this time
  by running si at 0x08048424, where call resides:



  (gdb) si





  0x0804841f	5	        printf("Hello World!\n");





  (gdb) si





  0x08048424	5	        printf("Hello World!\n");





  (gdb) x/i $eip





  => 0x8048424 <main+25>:	call   0x80482e0 <puts@plt>





  (gdb) si





  0x080482e0 in puts@plt ()



  The next instruction right after 0x8048424 is the first
  instruction at 0x080482e0 in puts function. In other words, gdb
  stepped into puts instead of stepping over it.

  Command: until

This command executes until the next line is greater than the
current line.

Suppose we have a function that execute a long loop:

  #include <stdio.h>



int add1000() {

    int total = 0;



    for (int i = 0; i < 1000; ++i){

        total += i;

    }



    printf("Done adding!\n");



    return total;

}



int main(int argc, char *argv[])

{

    add1000(1, 2);

    printf("Hello World!\n");

    return 0;

}

  Using next command, we need to press 1000 times for finishing
  the loop. Instead, a faster way is to use until:



  (gdb) b add1000





  Breakpoint 1 at 0x8048411: file hello.c, line 4.





  (gdb) r





  Starting program: /tmp/hello

  Breakpoint 1, add1000 () at hello.c:4

  4	    int total = 0;





  (gdb) until





  5	    for (int i = 0; i < 1000; ++i){





  (gdb) until





  6	        total += i;





  (gdb) until





  5	    for (int i = 0; i < 1000; ++i){





  (gdb) until





  8	    printf("Done adding!\n");



  Executing the first until, gdb stopped at line 5 since line 5
  is greater than line 4.

  Executing the second until, gdb stopped at line 6 since line 6
  is greater than line 5.

  Executing the third until, gdb stopped at line 5 since the loop
  still continues. Because line 5 is less than line 6, with the
  fourth until, gdb kept executing until it does not go back to
  line 5 anymore and stopped at line 8. This is a great way to
  skip over loop in the middle, instead of setting unneeded
  breakpoint.

  until can be supplied with an argument to explicitly execute to
  a specific line:



  (gdb) r





  Starting program: /tmp/hello

  Breakpoint 1, add1000 () at hello.c:4

  4	    int total = 0;





  (gdb) until 8





  add1000 () at hello.c:8

  8	    printf("Done adding!\n");



  Command: finish

This command executes until the end of a function and displays
the return value. finish is actually just a more convenient
version of until.

Using the add1000 function from the previous example and use
finish instead of until:



  (gdb) r





  Starting program: /tmp/hello

  Breakpoint 1, add1000 () at hello.c:4

  4	    int total = 0;





  (gdb) finish





  Run till exit from #0  add1000 () at hello.c:4

  Done adding!

  0x08048466 in main (argc=1, argv=0xffffd154) at hello.c:15

  15	    add1000(1, 2);

  Value returned is $1 = 499500



  Command: bt

This command prints the backtrace of all stack frames. A [margin:
backtrace
]backtracebacktrace is a list of currently active functions:

Suppose we have a chain of function calls:

  void d(int d) { };

void c(int c) { d(0); }

void b(int b) { c(1); }

void a(int a) { b(2); }



int main(int argc, char *argv[])

{

    a(3);

    return 0;

}

  bt can visualize such a chain in action:



  (gdb) b a





  Breakpoint 1 at 0x8048404: file hello.c, line 9.





  (gdb) r





  Starting program: /tmp/hello

  Breakpoint 1, a (a=3) at hello.c:9

  9	void a(int a) { b(2); }





  (gdb) s





  b (b=2) at hello.c:7

  7	void b(int b) { c(1); }





  (gdb) s





  c (c=1) at hello.c:5

  5	void c(int c) { d(0); }





  (gdb) s





  d (d=0) at hello.c:3

  3	void d(int d) { };





  (gdb) bt





  #0  d (d=0) at hello.c:3

  #1  0x080483eb in c (c=1) at hello.c:5

  #2  0x080483fb in b (b=2) at hello.c:7

  #3  0x0804840b in a (a=3) at hello.c:9

  #4  0x0804841b in main (argc=1, argv=0xffffd154) at hello.c:13



  Most-recent calls are placed on top and least-recent calls are
  near the bottom. In this case, d is the most current active
  function, so it has the index 0. Next is c, the 2[superscript:nd] active function, has the index 1 and so on with function b,
  function a, and finally function main at the bottom, the
  least-recent function. That is how we read a backtrace.

  Command: up

This command goes up one frame earlier the current frame.

Instead of staying in d function, we can go up to c function and
look at its state:



  (gdb) bt





  #0  d (d=0) at hello.c:3

  #1  0x080483eb in c (c=1) at hello.c:5

  #2  0x080483fb in b (b=2) at hello.c:7

  #3  0x0804840b in a (a=3) at hello.c:9

  #4  0x0804841b in main (argc=1, argv=0xffffd154) at hello.c:13





  (gdb) up





  #1  0x080483eb in c (c=1) at hello.c:3

  3	void b(int b) { c(1); }



  The output displays the current frame is moved to c and where
  the call to c is made, which is in function b at line 3.

  Command: down

Similar to up, this command goes down one frame later then the
current frame.

After inspecting c function, we can go back to d:



  (gdb) bt





  #0  d (d=0) at hello.c:3

  #1  0x080483eb in c (c=1) at hello.c:5

  #2  0x080483fb in b (b=2) at hello.c:7

  #3  0x0804840b in a (a=3) at hello.c:9

  #4  0x0804841b in main (argc=1, argv=0xffffd154) at hello.c:13





  (gdb) up





  #1  0x080483eb in c (c=1) at hello.c:3

  3	void b(int b) { c(1); }





  (gdb) down





  #0  d (d=0) at hello.c:1

  1	void d(int d) { };



  Command: info registers

This command lists the current values in commonly used registers.
This command is useful when debugging assembly and operating
system code, as we can inspect the current state of the machine.

Executing the command, we can see the commonly used registers:



  (gdb) info registers





  eax            0xf7faddbc	-134554180

  ecx            0xffffd0c0	-12096

  edx            0xffffd0e4	-12060

  ebx            0x0	0

  esp            0xffffd0a0	0xffffd0a0

  ebp            0xffffd0a8	0xffffd0a8

  esi            0xf7fac000	-134561792

  edi            0xf7fac000	-134561792

  eip            0x804841c	0x804841c <main+17>

  eflags         0x286	[ PF SF IF ]

  cs             0x23	35

  ss             0x2b	43

  ds             0x2b	43

  es             0x2b	43

  fs             0x0	0

  gs             0x63	99



  The above registers suffice for writing our operating system in
  later part.

  How debuggers work: A brief introduction

  How breakpoints work

When a programmer places a breakpoint somewhere in his code, what
actually happens is that the first opcode of the first
instruction of a statement is replaced with another instruction,
int 3 with opcode CCh:

[float Figure:
[Figure 0.17:
Opcode replacement, with int 3
]


+-----+-----+---------+                +-----+-----+----+
| 83  | ec  |   0c    |  \rightarrow
  | cc  | ec  | 0c |
+-----+-----+---------+                +-----+-----+----+
+---------------------+                +----------------+
|     sub esp,0x4     |                |     int 3      |
+---------------------+                +----------------+

]

int 3 only costs a single byte, making it efficient for
debugging. When int 3 instruction is executed, the operating
system calls its breakpoint interrupt handler. The handler then
checks what process reaches a breakpoint, pauses it and notifies
the debugger it has paused a debugged process. The debugged
process is only paused and that means a debugger is free to
inspect its internal state, like a surgeon operates on an
anesthetic patient. Then, the debugger replaces the int 3 opcode
with the original opcode and executes the original instruction
normally.

[float Figure:
[Figure 0.18:
Restore the original opcode, after int 3 was executed
]


+-----+-----+----+                +-----+-----+---------+
| cc  | ec  | 0c |  \rightarrow
  | 83  | ec  |   0c    |
+-----+-----+----+                +-----+-----+---------+
+----------------+                +---------------------+
|     int 3      |                |     sub esp,0x4     |
+----------------+                +---------------------+

]

It is simple to see int 3 in action. First, we add an int 3
instruction where we need gdb to stop:

  #include <stdio.h>



int main(int argc, char *argv[])

{

    asm("int 3");

    printf("Hello World\n");

    return 0;

}

  int 3 precedes printf, so gdb is expected to stop at printf.
  Next, we compile with debug enable and with Intel syntax:



  $ gcc -masm=intel -m32 -g hello.c -o hello



  Finally, start gdb:



  $ gdb hello



  Running without setting any breakpoint, gdb stops at printf
  call, as expected:



  (gdb) r





  Starting program: /tmp/hello

  Program received signal SIGTRAP, Trace/breakpoint trap.

  main (argc=1, argv=0xffffd154) at hello.c:6

  6	    printf("Hello World\n");



  The blue text indicates that gdb encountered a breakpoint, and
  indeed it stopped at the right place: the printf call, where
  int 3 preceded it.

  Single stepping

When breakpoint is implemented, it is easy to implement single
stepping: a debugger simply places another int 3 opcode in the
next instruction. So, when a programmer sets a breakpoint at an
instruction, the next instruction is automatically set by the
debugger, thus enable instruction by instruction debugging.
Similarly, source line by line debugging is just the placements
of the very first opcodes in the two statements with two int 3
opcodes.

  How a debugger understands high level source code

DWARF is a debugging file format used by many compilers and
debuggers to support source level debugging. DWARF contains
information that maps between entities in the executable binary
with the source files. A program entity can either be data or
code. A DIE, or [margin:
Debugging Information Entry
]Debugging Information EntryDebugging Information Entry, is a
description of a program entity. A DIE consists of a
tag, which specifies the entity
that the DIE describes, and a list of  attributes that describes
the entity. Of all the attributes, these two attributes enables
source-level debugging:

• Where the entity appears in the source files: which file and
  which line the entity appears.

• Where the entity appears in the executable binary: in which
  memory address the entity is loaded at runtime. With the
  precise address, gdb can retrieve correct value for a data
  entity, or place a correct breakpoint and stop accordingly for
  a code entity. Without the information of these addresses, gdb
  would not know where the entities are to inspect them.




+---------------------------------------------------------------------------------------------------------------------------------------------------+                          +------------------------------------------------------------------+
| hello.c                                                                                                                                           |                          | DIE                                                              |
+---------------------------------------------------------------------------------------------------------------------------------------------------+                          +------------------------------------------------------------------+
+--------------------------------------------------------------+------------------------------------------------------------------------------------+                          +------------------------------------------------------------------+
|   Line 1

  Line 2

\Rightarrow
 Line 3

  Line 5

  Line 6  | #include <stdio.h>

 

int main(int argc, char *argv[])

..........

..........

  |   

 

  \rightarrow
    | ....

....

main in hello.c is at 0x804840b in hello

....

.... |
+--------------------------------------------------------------+------------------------------------------------------------------------------------+                          +------------------------------------------------------------------+

                                                                                                                                                                                                     \downarrow
\uparrow


                                                                                                                                                                               +------------------------------------------------------------------+
                                                                                                                                                                               | hello (at 0x804840b)                                             |
                                                                                                                                                                               +------------------------------------------------------------------+
                                                                                                                                                                               +------------------------------------------------------------------+
                                                                                                                                                                               | ...8d 4c 24 04 83 e4 f0 ff 71 fc ....                            |
                                                                                                                                                                               +------------------------------------------------------------------+






In addition to DIEs, another binary-to-source mapping is the line
number table. The line number table maps between a line in the
source code and at which memory address is the start of the line
in the executable binary.

In sum, to successfully enable source-level debugging, a debugger
needs to know the precise location of the source files and the
load addresses at runtime. Address matching, between the image
layout of the ELF binary and the address where it is loaded, is
extremely important since debug information relies on correct
loading address at runtime. That is, it assumes the addresses as
recorded in the binary image at compile-time the same as at
runtime e.g. if the load address for .text section is recorded in
the executable binary at 0x800000, then when the binary actually
runs, .text should really be loaded at 0x800000 for gdb to be
able to correctly match running instructions with high-level code
statement. Address mismatching makes debug information useless,
as actual code at one address is displayed as code at another
address. Without this knowledge, we will not be able to build an
operating system that can be debugged with gdb.

When an executable binary contains debug info, readelf can
display such information in a readable format. Using the good old
hello world program:

  #include <stdio.h>



int main(int argc, char *argv[])

{

    printf("Hello World\n");



    return 0;

}

  and compile with debug info:



  $ gcc -m32 -g hello.c -o hello



  With the binary ready, we can look at the line number table
  with the command:



  $ readlelf -wL hello



  -w option prints all the debug information. In combination with
  its sub-option, only specific information is displayed. For
  example, with -L, only the line number table is displayed:



  Decoded dump of debug contents of section .debug_line:

  CU: hello.c:

  File name                            Line number    Starting
  address

  hello.c                                        6
  0x804840b

  hello.c                                        7
  0x804841c

  hello.c                                        9
  0x804842c

  hello.c                                       10
  0x8048431



  From the above output:

  CU shorts for Compilation Unit, a
    separately compiled source file. In the example, we only have
    one file, hello.c.

  File name displays the filename of the current compilation
    unit.

  Line number is the line number in the source file of which the
    line is not an empty line. In the example, line 8 is an empty
    line, so it does not appear.

  Starting address is the memory address where the line actually
    starts in the executable binary.

  With such crystal clear information, this is how gdb is able to
  set a breakpoint on a line easily. For placing breakpoints on
  variables and functions, it is time to look at the DIEs. To get
  the DIEs information from an executable binary, run the
  command:



  $ readlelf -wi hello



  -wi option lists all the DIE entries. This is one typical DIE
  entry:

   <0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)

      <c>   DW_AT_producer    : (indirect string, offset: 0xe):
  GNU C11 5.4.0 20160609 -masm=intel -m32 -mtune=generic
  -march=i686 -g -fstack-protector-strong

      <10>   DW_AT_language    : 12	(ANSI C99)

      <11>   DW_AT_name        : (indirect string, offset: 0xbe):
  hello.c

      <15>   DW_AT_comp_dir    : (indirect string, offset: 0x97):
  /tmp

      <19>   DW_AT_low_pc      : 0x804840b

      <1d>   DW_AT_high_pc     : 0x2e

      <21>   DW_AT_stmt_list   : 0x0

  Red This left-most number indicates the current nesting level
    of a DIE entry. 0 is the outer-most level DIE with its entity
    is the compilation unit. This means subsequent DIE entries
    with higher nesting level are all the children of this tag,
    the compilation unit. It makes sense, as all the entities
    must originate from a source file.

  Blue These numbers in hex format indicate the offsets into
    .debug_info section. Each meaningful information is displayed
    along with its offset. When an attribute references to
    another attribute, the offset is used to precisely identify
    the referenced attribute.

  Green These names with DW_AT_ prefix are the attributes
    attached to a DIE that describe an entity. Notable
    attributes:

    DW_AT_name

    DW_AT_comp_dir The filename of the compilation unit and the
      directory where compilation occurred. Without the filename
      and the path, gdb would not be able to display the
      high-level source, despite the availability of the debug
      info. Debug info only contains the mapping between source
      and binary, not the source code itself.

    DW_AT_low_pc

    DW_AT_high_pc The start and end of the current entity, which
      is the compilation unit, in the executable binary. The
      value in DW_AT_low_pc is the starting address.
      DW_AT_high_pc is the size of the compilation unit, when
      adding up to DW_AT_low_pc results in the end address of the
      entity. In this example, code compiled from hello.c starts
      at 0x804840b and end at \mathtt{0x804840b+0x2e=0x8048439}
.
      To really make sure, we verify with objdump:



      int main(int argc, char *argv[])

      {

       804840b:       8d 4c 24 04             lea
      ecx,[esp+0x4]

       804840f:       83 e4 f0                and
      esp,0xfffffff0

       8048412:       ff 71 fc                push   DWORD PTR
      [ecx-0x4]

       8048415:       55                      push   ebp

       8048416:       89 e5                   mov    ebp,esp

       8048418:       51                      push   ecx

       8048419:       83 ec 04                sub    esp,0x4

          printf("Hello World\n");

       804841c:       83 ec 0c                sub    esp,0xc

       804841f:       68 c0 84 04 08          push   0x80484c0

       8048424:       e8 b7 fe ff ff          call   80482e0
      <puts@plt>

       8048429:       83 c4 10                add    esp,0x10

          return 0;

       804842c:       b8 00 00 00 00          mov    eax,0x0

      }

       8048431:       8b 4d fc                mov    ecx,DWORD
      PTR [ebp-0x4]

       8048434:       c9                      leave

       8048435:       8d 61 fc                lea
      esp,[ecx-0x4]

       8048438:       c3                      ret

       8048439:       66 90                   xchg   ax,ax

       804843b:       66 90                   xchg   ax,ax

       804843d:       66 90                   xchg   ax,ax

       804843f:       90                      nop



      It is true: main starts at 804840b and end at 8048439,
      right after the ret instruction at 8048438. The
      instructions after 8048439 are just padding bytes inserted
      by gcc for alignment, which do not belong to main. Note
      that the output from objdump shows much more code past
      main. It is not counted, as the code is outside of hello.c,
      added by gcc for the operating system. hello.c contains
      only one function: main and this is why hello.c also starts
      and ends the same as main.

  Pink This number displays the abbreviation form of a tag. An
    abbreviation is the form of a DIE. When debug info is
    displayed with -wi, the DIEs are displayed with their values.
    -wa option shows abbreviations in the .debug_abbrev section:



    Contents of the .debug_abbrev section:

      Number TAG (0x0)

       1      DW_TAG_compile_unit    [has children]

        DW_AT_producer     DW_FORM_strp

        DW_AT_language     DW_FORM_data1

        DW_AT_name         DW_FORM_strp

        DW_AT_comp_dir     DW_FORM_strp

        DW_AT_low_pc       DW_FORM_addr

        DW_AT_high_pc      DW_FORM_data4

        DW_AT_stmt_list    DW_FORM_sec_offset

        DW_AT value: 0     DW_FORM value: 0

    .... more abbreviations ....



    The output is similar to a DIE output, with only attribute
    names and without any value. We can also say an abbreviation
    is a type of a DIE, as an abbreviation represents the
    structure of a particular DIE. Many DIEs share the same
    abbreviation, or structure, thus they are of the same type.
    An abbreviation number specifies which type a DIE is in the
    abbreviation table above. Abbreviations improve encoding
    efficiency (reduce binary size) because each DIE needs not to
    carry their structure information as pairs of attribute-value[footnote:
For example, data format such as YAML or JSON encodes its
attribute names along with its values. This simplifies encoding,
but with overhead.
], but simply refers to an abbreviation for correct decoding.

  Here are all the DIEs of hello represented as a tree:



  <Graphics file: C:/Users/Tu Do/os01/book_src/images/06/dwarf_tree.svg>
  <dwarf_tree>



In the figure [dwarf_tree], DW_TAG_subprogram represents a
function such as main. Its children are the DIEs of argc and
argv. With such precise information, matching source to binary is
an easy job for gdb.

If more than one compilation units exist in an executable binary,
the DIE entries are sorted according to the compilation order
from gcc. For example, suppose we have another test.c source file[footnote:
It can contain anything. Just a sample file.
] and compile it together with hello:



$ gcc -masm=intel -m32 -g test.c hello.c -o hello



Then, the all DIE entries in test.c are displayed before the DIE
entries in hello.c:

<0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)

      <c>   DW_AT_producer    : (indirect string, offset: 0x0):
  GNU C11 5.4.0 20160609

  -masm=intel -m32 -mtune=generic -march=i686 -g
  -fstack-protector-strong

      <10>   DW_AT_language    : 12       (ANSI C99)

      <11>   DW_AT_name        : (indirect string, offset: 0x64):
  test.c

      <15>   DW_AT_comp_dir    : (indirect string, offset: 0x5f):
  /tmp

      <19>   DW_AT_low_pc      : 0x804840b

      <1d>   DW_AT_high_pc     : 0x6

      <21>   DW_AT_stmt_list   : 0x0

   <1><25>: Abbrev Number: 2 (DW_TAG_subprogram)

      <26>   DW_AT_external    : 1

      <26>   DW_AT_name        : bar

      <2a>   DW_AT_decl_file   : 1

      <2b>   DW_AT_decl_line   : 1

      <2c>   DW_AT_low_pc      : 0x804840b

      <30>   DW_AT_high_pc     : 0x6

      <34>   DW_AT_frame_base  : 1 byte block: 9c
  (DW_OP_call_frame_cfa)

      <36>   DW_AT_GNU_all_call_sites: 1



  ....after all DIEs in test.c listed....



  <0><42>: Abbrev Number: 1 (DW_TAG_compile_unit)

      <43>   DW_AT_producer    : (indirect string, offset: 0x0):
  GNU C11 5.4.0 20160609

  -masm=intel -m32 -mtune=generic -march=i686 -g
  -fstack-protector-strong

      <47>   DW_AT_language    : 12       (ANSI C99)

      <48>   DW_AT_name        : (indirect string, offset: 0xc5):
  hello.c

      <4c>   DW_AT_comp_dir    : (indirect string, offset: 0x5f):
  /tmp

      <50>   DW_AT_low_pc      : 0x8048411

      <54>   DW_AT_high_pc     : 0x2e

      <58>   DW_AT_stmt_list   : 0x35

  ....then all DIEs in hello.c are listed....
